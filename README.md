# Food Order API using Mongoose + CRUD Operations

In this tutorial, we will create a simple Food Order API using MongoDB with Mongoose for database interaction and Express for handling HTTP requests. We'll implement CRUD (Create, Read, Update, Delete) operations for managing food items in the database.

### Prerequisites

Before you begin, make sure you have the following:

1. Node.js and npm installed on your system.
2. MongoDB installed and running on your machine.

### Step 1: Project Setup

Let's start by setting up our project and installing the necessary dependencies.

1. Create a new directory for your project and navigate into it.

2. Initialize a new Node.js project by running the following command:

```bash
npm init 
```

3. Install Express, Mongoose, and Cors packages using npm:

```bash
npm install express mongoose cors
```

### Step 2: Create the MongoDB Database and Collection

Here, Our `Database` is `foodDB` & `table / collection` is `foods`. We'll create a MongoDB collection called "foods" and insert some sample food items into it. Make sure your MongoDB is running before executing the following commands.

```javascript
// Using the MongoDB shell, create a collection called "foods"
db.createCollection('foods');

// Insert sample food items into the "foods" collection
db.foods.insertMany([
  { 'food': 'Chicken Biriyani', 'price': 200 },
  { 'food': 'Mutton Biriyani', 'price': 350 },
  { 'food': 'Egg Roll', 'price': 80 }
]);
```

### Step 3: Setting up the Server

Next, let's create the server file named `main.js` and set up the Express app.

```javascript
// Importing the Express library and assigning it to the variable 'express'.
const express = require('express');

// Importing the 'cors' middleware for enabling Cross-Origin Resource Sharing (CORS).
const cors = require('cors');

// Setting the port number to 3000.
const port = 3000;

// Importing the 'mongoose' library for MongoDB interaction.
const mongoose = require('mongoose');
// Importing the 'foodRouter' from the './routes/food.routes' file.
const foodRouter = require('./routes/food.routes')

// Setting the MongoDB connection string.
const db = 'mongodb://127.0.0.1:27017/foodDB';
// Connecting to MongoDB using Mongoose.
mongoose.connect(db)
    .then(() => {
        console.log('connencted to mongodb');
    })
    .catch((error) => {
        console.log('error connecting ' + error);
    })
    .finally(() => {
        console.log('node with mongo');
    });

// Creating an instance of Express.
const app = express();
// Enabling Cross-Origin Resource Sharing (CORS) for all routes.
app.use(cors());

// Parsing incoming request bodies in JSON format.
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// Attaching the 'foodRouter' to the '/api' route.
app.use('/api', foodRouter);
// Handling a GET request on the root path '/'.
app.get('/', (req, res) => {
    res.send("<h1>Welcome to Food Order</h1>")
});

// Starting the server and listening on the specified port.
app.listen(port, () => {
    console.log('Server started at ' + port);
});
```

### Step 4: Create the Mongoose Model

In this step, we'll create a Mongoose model for the "foods" collection. Create a new file named `food.model.js` inside the `models` directory.
- for each collections of the database we have to create a model class in mongoose or express.

```javascript
// Import the Mongoose library
const mongoose = require('mongoose');

// create an mongoose schema to define the database colection as
// mongose is a orm driver.
const foodSchema = mongoose.Schema({
    'food': { type: String, require: true },
    'price': { type: Number, require: true }
}, { versionKey: false });
// versionKey=> false mongoose will not create autogenerated field __v as versionkey any more.

/*
mongoose.model('identifier','schemaObject', 'collection_name');
*/
// Create a Mongoose model for the "foods" collection using the previously defined schema.
module.exports = mongoose.model('food1', foodSchema, 'foods');
// The model will be identified as "food1" and will correspond to the "foods" collection in MongoDB.

// console.log a message indicating that the food model is ready to use.
console.log('food model is ready to use');
```

### Step 5: Create the Food Routes

Now, let's create the routes for our Food API. Create a new file named `food.routes.js` inside the `routes` directory.

```javascript
// Importing required modules
const express = require('express');
// consuming the food model
const foodModel = require('../model/food.model');

// Creating an instance of the Express Router
const foodRouter = express.Router();

// Route to fetch all foods info from MongoDB
// fetching all foods info from mongodb using mongoose + express + node.js
foodRouter.get('/foods', (req, res) => {
    foodModel.find({}).exec()
        .then((foodInfo) => {
            // Sending the response as a JSON array containing the food information
            res.status(200).json(foodInfo);
        })
        .catch((error) => {
            // Handling any errors that occur during the process
            if (error)
                res.status(200).json({ 'message': 'error' });
        })
});

// Route to fetch a specific food item by its ID from MongoDB
foodRouter.get('/food/:id', (req, res) => {
    foodModel.findOne({ '_id': req.params.id }).exec()
        .then((foodInfo) => {
            // If a matching food item is found, send it as a JSON object
            if (!foodInfo)
                res.status(200).json({ 'message': 'no such food found !' });
            else
                res.status(200).json(foodInfo);
        })
        .catch((error) => {
            // Handling any errors that occur during the process
            if (error) res.status(200).json({ 'message': error });
        });
});

// Route to fetch food items within a given price range from MongoDB
foodRouter.get('/food/:lim1/:lim2', (req, res) => {
    let l1 = req.params.lim1;
    let l2 = req.params.lim2;
    foodModel.find({
        $and: [{ 'price': { $gte: l1 } }, { 'price': { $lte: l2 } }]
    })
        .exec()
        .then((foodInfo) => {
            // If matching food items are found, send them as a JSON array
            if (!foodInfo)
                res.status(200).json({ 'message': 'no such record found !' });
            else
                res.status(200).json(foodInfo);
        })
        .catch((error) => {
            // Handling any errors that occur during the process
            res.status(200).json({ 'message': error });
        });
});

// Route to adding a new food information into the database.
foodRouter.post('/food', (req, res) => {
    // let's assume front end will send those parameter to node to insert the document.
    let dataToSubmit = {
        'food': req.body.food_name,
        'price': req.body.food_price
    };
    let newFood = new foodModel(dataToSubmit);
    newFood.save()
        .then((foodInfo) => {
            // res.status(200).json(foodInfo);
            // Sending the appropriate response message based on the outcome
            if (!foodInfo)
                res.status(200).json({ 'message': 'error inserting a food info' });
            else
                res.status(200).json({ 'message': 'One food record hasbeen added' });
        })
        .catch((error) => {
            // Handling any errors that occur during the process
            res.status(200).json(error);
        });
});

// Route to delete a specific food item by its ID from MongoDB
foodRouter.delete('/food/:id', (req, res) => {
    foodModel.deleteOne({ '_id': req.params.id })
        .then((foodInfo) => {
            // Sending the appropriate response message based on the outcome
            if (!foodInfo)
                res.status(200).json({ 'message': 'no such records found' });
            else
                res.status(200).json({ 'message': 'One food has been deleted' });
        })
        .catch((error) => {
            // Handling any errors that occur during the process
            res.status(200).json({ 'message': error });
        })
});

// Route to update a specific food item by its ID in MongoDB using PUT or PATCH
foodRouter.all('/food/:id', (req, res) => {
    if (req.method == 'PUT' || req.method == 'PATCH') {
        foodModel.updateOne(
            { '_id': req.params.id },
            { $set: { 'food': req.body.food_name, 'price': req.body.food_price } })
            .then((foodInfo) => {
                // Sending the appropriate response message based on the outcome
                if (!foodInfo)
                    res.status(200).json({ 'message': 'error while updating...' });
                else
                    res.status(200).json({ 'message': 'One food has been updated' });
            })
            .catch((error) => {
                // Handling any errors that occur during the process
                res.status(200).json({ 'message': error });
            });
    } else {
        // If the HTTP method is not PUT or PATCH, send an appropriate response
        res.status(200).json({ 'message': req.method + ' does not suported' });
    }
});

// Exporting the foodRouter so that it can be used in other modules
module.exports = foodRouter;

// console.log a message indicating that the foodRouter is ready to use
console.log('foodRouter is ready to use');
```

### Step 6: Run the API

Finally, let's run the server and test the Food Order API using tools like Postman or any REST client.

1. Start the server by running the following command in the terminal:

```bash
node main.js
```

2. Open your browser or REST client and access the endpoints to test the API:

   - Fetch all food items: GET http://localhost:3000/api/foods
   - Fetch a specific food item by ID: GET http://localhost:3000/api/food/:id
   - Fetch food items within a price range: GET http://localhost:3000/api/food/:lim1/:lim2
   - Add a new food item: POST http://localhost:3000/api/food
   - Delete a food item by ID: DELETE http://localhost:3000/api/food/:id
   - Update a food item by ID: PUT http://localhost:3000/api/food/:id

That's it! You have successfully created a Food Order API using Mongoose with CRUD operations. You can further enhance this API by adding validation, authentication, and error handling as per your requirements.


## Resource

- **1. MongoDB Embedded Collections:** In MongoDB, embedded collections allow the storage of related data within a single document. This means that instead of creating separate collections for related data, the data can be nested directly within the parent document. This approach is particularly useful when dealing with one-to-many relationships, as it reduces the need for complex joins and can improve read and write performance. However, it's essential to carefully consider data access patterns and the potential for document growth when using embedded collections.

- **2. Aggregate Function Group By Clause:** In the context of databases and data processing, the "group by" clause is used in aggregate functions to group data based on a specific field or set of fields. When applied, it consolidates rows with similar values in the specified field(s) into a single row, and aggregate functions (like SUM, COUNT, AVG, etc.) are then applied to calculate values across those groups. This is particularly useful for generating summary reports, performing data analysis, and obtaining insights from large datasets. The "group by" clause is commonly used in SQL-based databases and is also supported by MongoDB's aggregation framework for more advanced data manipulations.

### There are many Third party drivers:
- MongoDB Native Driver
- Mongoose Driver
- MongoJS Driver

### ORM => Object-Relational Mapping

### Database Information:

- **Database**: foodDB
- **Table/Collection**: foods

### Foods Class Documentation:

The `Foods` class is a JavaScript Object-Relational Mapping (ORM) that provides an interface for interacting with the `foodDB` database's `foods` collection. This class facilitates performing CRUD (Create, Read, Update, Delete) operations on food items stored in the database. It allows you to manage food-related data efficiently by providing methods for inserting, deleting, updating, and retrieving food items.
- `food_id`: A property representing the unique identifier of a food item.
- `food_name`: A property representing the name of the food item.
- `food_desc`: A property representing the description or additional information about the food item.

```javascript
export class Foods {
  public food_id;
  public food_name;
  public food_desc;

  insert() {
    // Insert a new food item into the collection
  }

  delete() {
    // Delete a food item from the collection
  }

  update() {
    // Update a food item in the collection
  }

  findOne() {
    // Find and retrieve a single food item from the collection
  }

  find() {
    // Find and retrieve multiple food items from the collection
  }
}
```

### mongoose connect to MongoDB with the `mongoose.connect()` method:

```javascript
const db = mongodb://127.0.0.1:27017/<database_name>
mongoose.connect(db)
```
